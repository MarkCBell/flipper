
''' A module for performing symbolic calculations using Python. '''

import flipper

def gram_schmidt(basis):
	''' Return an orthonormal basis for the subspace generated by basis. '''
	
	basis = [list(row) for row in basis]
	
	dot = flipper.kernel.matrix.dot
	for i in range(len(basis)):
		for j in range(i):
			a, b = dot(basis[i], basis[j]), dot(basis[j], basis[j])
			basis[i] = [b * x - a * y for x, y in zip(basis[i], basis[j])]
	return basis

def project(vector, basis):
	''' Return the projection of vector to the subspace generated by basis. '''
	
	dot = flipper.kernel.matrix.dot
	orthogonal_basis = gram_schmidt(basis)
	linear_combination = [dot(vector, row) / dot(row, row) for row in orthogonal_basis]
	return [sum(a * b[i] for a, b in zip(linear_combination, orthogonal_basis)) for i in range(len(vector))]

def perron_frobenius_eigen(matrix, vector):
	''' Return the dominant eigenvalue of matrix and the projection of vector to its corresponding eigenspace.
	
	Assumes (and checks) that the dominant eigenvalue is real. '''
	
	dot = flipper.kernel.matrix.dot
	eigenvalues = matrix.char_poly().roots()
	if len(eigenvalues) == 0:
		raise flipper.AssumptionError('Matrix is not PF, no primitive eigenvalues.')
	
	# !?! Check this 30.
	dominant_eigenvalue = max(eigenvalues, key=lambda x: x.algebraic_approximation(30))
	
	# We will calculate the eigenvector ourselves.
	N = flipper.kernel.NumberField(dominant_eigenvalue)
	kernel_basis = (matrix - N.lmbda).kernel()  # Sage is much better at this than us for large matrices.
	# Can't do division so can't do: eigenvector = project(vector, kernel_basis)
	row_lengths = [dot(row, row) for row in kernel_basis]
	product_lengths = [flipper.kernel.product([row_lengths[j] for j in range(len(kernel_basis)) if j != i]) for i in range(len(kernel_basis))]
	linear_combination = [dot(vector, row) * product_length for row, product_length in zip(kernel_basis, product_lengths)]
	
	return N.lmbda, [sum(a * n[i] for a, n in zip(linear_combination, kernel_basis)) for i in range(matrix.width)]
