
# Exact symbolic calculations using types representing algebraic numbers. This is used to:
#	compute the stable lamination exactly.
#	compute splitting sequences.
#
# This module selects and imports the appropriate library for manipulating algebraic numbers.
# Currently there are three to choose from based on: sage, sympy and None, the last of which is
# a dummy library which can't do anything but makes sure that the imports never fail.
# Currently Sage is the best by a _large_ margin and so this is our first choice.
#
# Each library provides a class called AlgebraicType based off of 
# Flipper.kernel.symboliccomputation_dummy.AlgebraicType. The main methods of which are:
#	algebraic_simplify(self)
#		Puts self into a standard form.
#	algebraic_minimal_polynomial_coefficients(self):
#		Returns the coefficients of the minimal polynomial of this algebraic number.
#	algebraic_approximate(self, accuracy, degree=None, power=1):
#		Returns an algebraic approximation of this algebraic number to the requested power, 
#		correct to the requested accuracy.
#
# It also provides:
#	def algebraic_degree(self):
#		Returns the degree of this number.
#	def algebraic_log_height(self):
#		Returns the log height of this number.
# but these are derived automatically from AlgebraicType.algebraic_minimal_polynomial_coefficients.
#
# Typically each library sets these methods to work with its underlying type.
#
# Each library also provides a function for creating AlgebraicTypes:
#	Perron_Frobenius_eigen(matrix):
#		Given a Perron-Frobenius matrix (of type Flipper.kernel.matrix.Matrix) this must 
#		return its PF eigenvector, that is eigenvector with corresponding eigenvalue with 
#		largest absolute value and whose sum of entries is one. Each entry of the eigenvector 
#		must be an element of a  Flipper.kernel.numberfield.NumberField generated by an 
#		element of AlgebraicType
#
# and a _name variable containing a string identifying the module. This is very useful for debugging.

# You can provide your own algebraic number library so long as it provides these methods and can be cast to a string via str().

_name = None

if _name is None:
	try:
		import Flipper.kernel.symboliccomputation_sage
		AlgebraicType = Flipper.kernel.symboliccomputation_sage.AlgebraicType
		Perron_Frobenius_eigen = Flipper.kernel.symboliccomputation_sage.Perron_Frobenius_eigen
		_name = Flipper.kernel.symboliccomputation_sage._name
	except ImportError:
		pass

if _name is None:
	try:
		import Flipper.kernel.symboliccomputation_sympy
		AlgebraicType = Flipper.kernel.symboliccomputation_sympy.AlgebraicType
		Perron_Frobenius_eigen = Flipper.kernel.symboliccomputation_sympy.Perron_Frobenius_eigen
		_name = Flipper.kernel.symboliccomputation_sympy._name
	except ImportError:
		pass

if _name is None:
	try:
		import Flipper.kernel.symboliccomputation_dummy
		AlgebraicType = Flipper.kernel.symboliccomputation_dummy.AlgebraicType
		Perron_Frobenius_eigen = Flipper.kernel.symboliccomputation_dummy.Perron_Frobenius_eigen
		_name = Flipper.kernel.symboliccomputation_dummy._name
	except ImportError:
		pass

#############################################################################
# We also build some helper functions using these.

def compute_powers(a, b):
	# Given (real > 1) algebraic numbers a == c^m and b == c^n where c is another algebraic number and m & n are coprime 
	# integers returns m, n. This uses a variant of the Euclidean algorithm and can probably be done smarter.
	
	if a == b:
		return (1, 1)
	elif a > b:
		m2, n2 = compute_powers(a / b, b)
		return (m2 + n2, n2)
	else:
		m2, n2 = compute_powers(a, b / a)
		return (m2, n2 + m2)

